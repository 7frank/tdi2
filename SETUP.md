# Spring Boot Style DI for React - Setup Guide

## 🚀 Quick Start

1. **Install dependencies** (already done in your project):
   ```bash
   npm install
   ```

2. **Run the DI transformer**:
   ```bash
   npm run di:transform
   ```

3. **Start development**:
   ```bash
   npm run dev
   ```

## 🔧 How It Works

### 1. Service Definition
Create services using the `@Service` decorator:

```typescript
@Service({ token: EXAMPLE_API_TOKEN })
export class ExampleApiService implements ExampleApiInterface {
  constructor(
    @Inject(LOGGER_TOKEN) private logger?: LoggerService
  ) {}
}
```

### 2. Build-Time Transformation
The transformer (`tools/di-transformer.ts`) scans your code and generates:
- `src/generated/di-config.ts` - Factory functions and DI configuration
- `src/services/AutoGeneratedRegistry.ts` - Service registry

### 3. Runtime Container
The container resolves dependencies at runtime:
```typescript
const container = new CompileTimeDIContainer();
container.loadConfiguration(DI_CONFIG);
```

### 4. React Integration
Use services in React components via hooks:
```typescript
const apiService = useService<ExampleApiInterface>(EXAMPLE_API_TOKEN);
```

## 📝 Key Features

### Current Implementation
- ✅ Class-based services with `@Service` decorator
- ✅ Constructor injection with `@Inject`
- ✅ Token-based dependency resolution
- ✅ Singleton scope support
- ✅ React Context integration
- ✅ Build-time code generation
- ✅ Vite plugin integration

### Future Possibilities (with marker interfaces)
- 🔮 Function component DI: `function App(services: {api: Inject<ApiInterface>})`
- 🔮 Automatic transformation of function signatures
- 🔮 Type-safe service dependencies
- 🔮 Hot reload support for DI changes

## 🎯 Benefits

1. **Spring Boot Familiarity**: Uses similar patterns to Spring's `@Service` and `@Autowired`
2. **Type Safety**: Full TypeScript support with compile-time checking
3. **Build-Time Optimization**: No runtime reflection or metadata
4. **Tree Shaking**: Only used services are included in bundles
5. **Testability**: Easy mocking and dependency substitution

## 🔄 Development Workflow

1. Create/modify services with `@Service` and `@Inject`
2. Run `npm run di:transform` to regenerate DI config
3. Services are automatically available in React components

The Vite plugin can watch for changes and auto-regenerate the DI configuration during development.

## 🧪 Testing

Run the test script to verify DI container works:
```bash
node test-di.js
```

## 📁 File Structure

```
src/
├── di/                     # DI framework code
│   ├── container.ts        # DI container implementation  
│   ├── context.tsx         # React context and hooks
│   ├── decorators.ts       # @Service, @Inject decorators
│   ├── markers.ts          # Future: marker interfaces
│   └── types.ts           # Type definitions
├── services/              # Your business services
│   ├── ExampleApiService.ts
│   └── ConsoleLoggerService.ts
├── generated/             # Auto-generated (don't edit)
│   └── di-config.ts       # DI configuration
└── App.tsx               # Main app with DI usage
```

## 🎨 Next Steps

1. Add more services and test dependency injection
2. Implement scoped services for component lifecycles  
3. Add the functional DI approach with marker interfaces
4. Create testing utilities for mocking services
5. Add validation and better error messages