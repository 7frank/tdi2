import { describe, it, expect, beforeEach } from 'vitest';
import { CompileTimeDIContainer } from '@tdi2/di-core/container';
import { ProductServiceInterface } from '../../services/ProductService';
import { CartServiceInterface } from '../../services/CartService';
import { UserServiceInterface } from '../../services/UserService';
import { InventoryServiceInterface } from '../../services/InventoryService';

// Mock DI_CONFIG for testing - normally auto-generated by Vite plugin
const MOCK_DI_CONFIG = {
  services: [
    {
      token: 'ProductServiceInterface',
      implementation: () => import('../../services/ProductService').then(m => m.ProductService)
    },
    {
      token: 'CartServiceInterface', 
      implementation: () => import('../../services/CartService').then(m => m.CartService)
    },
    {
      token: 'UserServiceInterface',
      implementation: () => import('../../services/UserService').then(m => m.UserService)
    },
    {
      token: 'InventoryServiceInterface',
      implementation: () => import('../../services/InventoryService').then(m => m.InventoryService)
    },
    {
      token: 'ProductRepositoryInterface',
      implementation: () => import('../../repositories/ProductRepository').then(m => m.ProductRepository)
    },
    {
      token: 'UserRepositoryInterface',
      implementation: () => import('../../repositories/UserRepository').then(m => m.UserRepository)
    }
  ]
};

// DI Integration Tests using TDI2 Autowiring
// Test how services work together through dependency injection
describe('DI Integration Tests', () => {
  let container: CompileTimeDIContainer;
  let productService: ProductServiceInterface;
  let cartService: CartServiceInterface;
  let userService: UserServiceInterface;
  let inventoryService: InventoryServiceInterface;

  beforeEach(async () => {
    // Create fresh DI container for each test using TDI2 pattern
    container = new CompileTimeDIContainer();
    
    // Load configuration like in main.tsx (normally auto-generated)
    await container.loadConfiguration(MOCK_DI_CONFIG);

    // Resolve services from container using TDI2 autowiring
    productService = container.resolve<ProductServiceInterface>('ProductServiceInterface');
    cartService = container.resolve<CartServiceInterface>('CartServiceInterface');
    userService = container.resolve<UserServiceInterface>('UserServiceInterface');
    inventoryService = container.resolve<InventoryServiceInterface>('InventoryServiceInterface');
  });

  describe('TDI2 Autowiring Resolution', () => {
    it('should resolve all services from DI container', () => {
      expect(productService).toBeDefined();
      expect(cartService).toBeDefined();
      expect(userService).toBeDefined();
      expect(inventoryService).toBeDefined();
    });

    it('should inject dependencies correctly through @Service decorators', () => {
      // Services should have their dependencies injected automatically
      expect(productService).toBeDefined();
      expect(cartService).toBeDefined();
      
      // CartService should have InventoryService injected
      expect(cartService.state).toBeDefined();
      expect(productService.state).toBeDefined();
    });

    it('should maintain singleton instances', () => {
      // Resolve same service multiple times
      const productService1 = container.resolve<ProductServiceInterface>('ProductServiceInterface');
      const productService2 = container.resolve<ProductServiceInterface>('ProductServiceInterface');

      // Should be same instance (singleton pattern)
      expect(productService1).toBe(productService2);
    });
  });

  describe('Service Cross-Communication', () => {
    it('should handle product loading and cart interaction', async () => {
      // Arrange - Load products
      await productService.loadProducts();
      expect(productService.state.products.length).toBeGreaterThan(0);

      const firstProduct = productService.state.products[0];
      const initialCartItems = cartService.state.items.length;

      // Act - Add product to cart (this uses CartService -> InventoryService interaction)
      try {
        await cartService.addItem(firstProduct, 1);

        // Assert - Cart should update if stock available
        expect(cartService.state.items.length).toBe(initialCartItems + 1);
        expect(cartService.state.items[0].id).toBe(firstProduct.id);
        expect(cartService.state.totalItems).toBe(1);
      } catch (error) {
        // If stock unavailable, should get proper error
        expect(error.name).toBe('InsufficientStockError');
      }
    });

    it('should enforce stock constraints across services', async () => {
      // Arrange
      await productService.loadProducts();
      const product = productService.state.products[0];
      
      // Reserve all available stock
      const stockLevel = await inventoryService.getStockLevel(product.id);
      if (stockLevel > 0) {
        await inventoryService.reserveStock(product.id, stockLevel);

        // Act & Assert - Cart should respect inventory constraints
        await expect(cartService.addItem(product, 1))
          .rejects.toThrow('Insufficient stock');
      } else {
        // If no stock, should immediately fail
        await expect(cartService.addItem(product, 1))
          .rejects.toThrow('Insufficient stock');
      }
    });

    it('should handle user authentication workflow', async () => {
      // Arrange
      expect(userService.state.isAuthenticated).toBe(false);

      // Act - Login with demo credentials
      const loginSuccess = await userService.login('demo@example.com', 'password');

      // Assert
      expect(loginSuccess).toBe(true);
      expect(userService.state.isAuthenticated).toBe(true);
      expect(userService.state.currentUser?.email).toBe('demo@example.com');
    });
  });

  describe('Reactive State Propagation', () => {
    it('should maintain reactive state across service boundaries', async () => {
      // Arrange - Set up cart with items
      await productService.loadProducts();
      const product = productService.state.products[0];
      
      try {
        await cartService.addItem(product, 2);

        // Act - Apply discount
        const discountApplied = await cartService.applyDiscountCode('WELCOME20');

        if (discountApplied) {
          // Assert - State updates propagate correctly
          expect(cartService.state.appliedDiscounts).toHaveLength(1);
          expect(cartService.state.discountAmount).toBe(20);
          expect(cartService.state.totalPrice).toBeLessThan(cartService.state.subtotal);
        }
      } catch (error) {
        // If insufficient stock, test still validates service interaction
        expect(error.name).toBe('InsufficientStockError');
      }
    });

    it('should handle search and filter operations', async () => {
      // Arrange
      await productService.loadProducts();
      
      // Act - Search for products
      productService.searchProducts('laptop');
      const searchResults = productService.filteredProducts;

      // Assert - Filtered results should work
      if (searchResults.length > 0) {
        searchResults.forEach(product => {
          const matchesSearch = 
            product.name.toLowerCase().includes('laptop') ||
            product.description.toLowerCase().includes('laptop') ||
            product.tags.some(tag => tag.toLowerCase().includes('laptop'));
          expect(matchesSearch).toBe(true);
        });
      }

      // Act - Apply category filter
      productService.setFilter({ category: 'Electronics' });
      const categoryResults = productService.filteredProducts;

      // Assert - Should filter correctly
      categoryResults.forEach(product => {
        expect(product.category).toBe('Electronics');
      });
    });
  });

  describe('TDI2 Container Lifecycle', () => {
    it('should provide access to all registered services', () => {
      // Act - Get all service registrations
      const serviceTypes = [
        'ProductServiceInterface',
        'CartServiceInterface', 
        'UserServiceInterface',
        'InventoryServiceInterface',
        'ProductRepositoryInterface',
        'UserRepositoryInterface'
      ];

      // Assert - All services should be resolvable through TDI2
      serviceTypes.forEach(serviceType => {
        expect(() => container.resolve(serviceType)).not.toThrow();
      });
    });

    it('should handle service initialization properly', async () => {
      // Arrange - Services should initialize automatically
      await new Promise(resolve => setTimeout(resolve, 100)); // Allow initialization
      
      // Assert - Services should be in proper initial state
      expect(productService.state.loading).toBe(false);
      expect(cartService.state.items).toEqual([]);
      expect(userService.state.isAuthenticated).toBe(false);
    });
  });
});