- title: "Issue sync CLI tool"
  body: |
    create a small cli that helps us sync issues with github projects / issues
  state: "open"
  labels: 
    - "enhancement"
    - "cli" 
    - "sync"
    - "ordered-log"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Create showcases for more complex scenarios"
  body: |
    e.g. complex forms https://claude.ai/chat/48ebf950-986b-476d-bb0c-09a5c87fe041
  state: "open"
  labels:
    - "enhancement"
    - "documentation"
    - "examples" 
    - "ordered-log"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "useObservable"
  body: |
    what is RSI structurally (something else?, MVC,MVVM, MVP .. it can be all of them if implemented in a certain way)
      - with proxy state
      - with observables
    - see [comparision](./docs/misc/view-logic-pattern.md)

    - establish / evaluate rrecipe and establish dos and donts
      - **maybe** dont subscribe manually oin FC only use state of pbservasbalble and create functions that trigger changes but dont make them subscribable
      - **maybe** use robservables for interservice communication
      - **maybe** but then again maybe we dont need that
      - **...** explore what are good and bad patterns here by looking what is out there
      - TBA
  state: "open"
  labels:
    - "enhancement"
    - "architecture"
    - "observables"
    - "ordered-log"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Evaluate composability of DI"
  body: |
    we could create @Services(scope="dev")
    - now we could have one or multiple DI_CONFIG
    - that we could **compose**
    - or **filter**
    - we could nest them
      - maybe a global and one for a certain subtree e.g. multiple forms or pages
    - in essence we would have freedom to combine them as we want which could give us opportunites when injecting
  state: "open"
  labels:
    - "enhancement"
    - "dependency-injection"
    - "architecture"
    - "ordered-log"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "⚠️ interfaces still not working with generic any"
  body: |
    > Inject<ExampleApiInterface>;

    > Validation Issues:
    > Missing: UserApiServiceImpl -> CacheInterface_any
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "generics"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "FIXME TodoApp TodoService2 isnt properly injected"
  body: |
    it was not properly injected in case there where two or more interface with the same name e.g. "TodoServiceInterface" and @Services that impplement them
    - Fix or use monorepo/apps/legacy/src/di.integration.test.tsx for this scenario
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "FIXME having two different classes of the same name will one not be resolved properly"
  body: |
    e.g.:

    1 TodoService implements TodoServiceInterface
    2 TodoService implements TodoServiceType
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "FIXME duplicated keys see generated list of services"
  body: |
    potential duplicate
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Is DI scope using import path"
  body: |
    potential duplicate
    - if say we have two "implements UserRepoInterface"
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "In case of multiple unnamed generic interfaces we should throw an error or warning"
  body: |
    (Inject<{ name: string; email: string }>;)

    evaluate scenarios

    - to make it easier we probably want to enforce a rule/warning that Inject interfaces need to contain inline types
    - or we have some rule that warns if the Inject is not a single type/interface Inject<Foo> where Foo can be any interfac/type but must be itself not generic or subtyped...
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "generics"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Fixme: example which his generating invalid code"
  body: |
    ```typescript
    export function DemographicsForm(props: DemographicsFormProps) {
      const { services, onComplete } = props;

      const { demographicsForm } = services;
    }
    ```
  state: "open"
  labels:
    - "bug"
    - "code-generation"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "FIXME this type of destructuring requires a test and a fix as it is not properly transformed"
  body: |
    ```typescript
    interface AppProps {
      services: {
        todoService: Inject<TodoServiceInterface>;
        appState: Inject<AppStateServiceInterface>;
        notifications: Inject<NotificationServiceInterface>;
      };
    }

    export function TodoApp2({
      services: { todoService, appState, notifications },
    }: AppProps) {}
    ```
  state: "open"
  labels:
    - "bug"
    - "dependency-injection"
    - "transformation"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "FIXME could not fast refrest useDi export incompatible"
  body: |
    useDi export is incompatible with fast refresh functionality
  state: "open"
  labels:
    - "bug"
    - "development"
    - "hot-reload"
    - "di-bugs"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Profile decorator and marker"
  body: |
    Add Profile decorator and marker functionality for performance monitoring and debugging
  state: "open"
  labels:
    - "enhancement"
    - "decorators"
    - "profiling"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Lazy decorator and marker"
  body: |
    Add Lazy decorator and marker for lazy loading of services and components
  state: "open"
  labels:
    - "enhancement"
    - "decorators"
    - "lazy-loading"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "CLI"
  body: |
    which implements "which implemetnation belongs to <interface> " search
    - use cas edriven more feature, goal reduce DI friction for DX

    "faster" what causes this? **and** alternative to dependency viewer
  state: "open"
  labels:
    - "enhancement"
    - "cli"
    - "developer-experience"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Test mobx in favor of valtio"
  body: |
    > maybe the opproblem with valtio is more a hot reloading problem than actually valtios fault

    - https://www.npmjs.com/package/mobx-react-lite
    - valtio needs a "proxy" state and a "snap" for reactivity
    - mobx might be able to only use one "state-proxy"
      - there is this makeAutoObservable which we might be able to inject into the class constructor of new "@Service" annotated classes at compile time
      - there also is the Observer FC that we need to inject into FC that use "Inject" - Marker for observablility to work
  state: "open"
  labels:
    - "enhancement"
    - "state-management"
    - "mobx"
    - "evaluation"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Check for shared logic in these two and generate unit tests"
  body: |
    - 7frank/tdi2/monorepo/packages/di-core/tools/shared/RecursiveInjectExtractor.ts
    - 7frank/tdi2/monorepo/packages/di-core/tools/shared/SharedDependencyExtractor.ts
  state: "open"
  labels:
    - "testing"
    - "refactoring"
    - "unit-tests"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Fix or remove debug endpoints"
  body: |
    - http://localhost:5173/_di_debug
    - http://localhost:5173/_di_interfaces
    - http://localhost:5173/_di_configs"
    - if removed, remove middleware endpoints too
  state: "open"
  labels:
    - "refactoring"
    - "cleanup"
    - "debug"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Create do's and don't for valtio proxies / document quirks"
  body: |
    or rather a note atm, destructuring is reactive setting props directly in a service is not due to reasons
      - we might be able to add a compile step later that utilized destructuring and thus triggers this automatically

    ```typescript
      setFilter(status: "all" | "active" | "completed"): void {
        // Note: by destructuring we seem to trigger reactivity via the proxy
        this.state.filter = { ...this.state.filter, status };
        // this.state.filter.status = status;
      }
    ```
  state: "open"
  labels:
    - "documentation"
    - "valtio"
    - "best-practices"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Explore implications of not using the value provided by useSnapshot in code"
  body: |
    ```typescript
    serviceInstance=...
    const state = proxy(serviceInstance);
    const snap = useSnapshot(state);
    ```
  state: "open"
  labels:
    - "investigation"
    - "valtio"
    - "performance"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Di-core tests generate transformed files in the wrong directory"
  body: |
    "../../"
  state: "open"
  labels:
    - "bug"
    - "testing"
    - "file-paths"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Hack the stack for console to get proper line numbers when logging error and so on not the monkey patched"
  body: |
    Implement stack trace manipulation to provide accurate line numbers for console logging instead of showing monkey-patched locations
  state: "open"
  labels:
    - "enhancement"
    - "debugging"
    - "console"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Evaluate framework"
  body: |
    [EvaluationPlan](./monorepo/docs/EvaluationPlan.md)
  state: "open"
  labels:
    - "evaluation"
    - "framework"
    - "documentation"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Article on dev.to with todoapp and core features"
  body: |
    use existing docs
  state: "open"
  labels:
    - "documentation"
    - "article"
    - "marketing"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "**fix test files** missing test file dependency-tree-builder-test.ts generate one"
  body: |
    Generate missing test file dependency-tree-builder-test.ts
  state: "open"
  labels:
    - "bug"
    - "testing"
    - "missing-files"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "**fix test files** context.test.tsx_"
  body: |
    Fix missing test file context.test.tsx_
  state: "open"
  labels:
    - "bug"
    - "testing"
    - "missing-files"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Use falso in tests and fixtures, we don't want the ai to hard code any solutions"
  body: |
    Replace hardcoded test data with falso library to create more realistic and maintainable test fixtures
  state: "open"
  labels:
    - "testing"
    - "fixtures"
    - "enhancement"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Service-registry / autoregistry in .tdi generated"
  body: |
    not used? at least configured wrong, so problaby redundant
    - 7frank/tdi2/examples/tdi2-basic-example/src/.tdi2/registry.ts
  state: "open"
  labels:
    - "bug"
    - "service-registry"
    - "cleanup"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Split the code base into a npm monorepo"
  body: |
    - [✅] tdi2-core
    - tdi2-react-utils
      - e.g. di dependency viewer and elk dpendencies
    - tdi2-documentation
      - contain core examples for all features
    - todo-app
      - comprehensive implementation of tdi react and native di
    - logging
      - otel **FIXME** dependencies broken in generator for services that are not in legacy

    > suggest different module structure if that makes sense to you
    > create linux shell scripts for the heavy liftig of the refactoring enumerate the scripts and create an artifact for each
    > dont recreate files solely for imports let that be handled by the shell scripts

    #### actions taken

    - divide and conquery
    - fits in your head
    - do one thing but one thing good

    > first generate directory structure so that we can refactor at all `git ls-files`

    > Prompt: maybe first move files into proper directory structure and fix dependencies and only later add package.json for each ? but lets do this incrementally first create the script for the directory strucutre and the one to move the files

    > Prompt: the package.json files for each package and and app for now should not contain any build stripts. instead i want to just import the plain files from there, the monorepo should for now only be used structurally. this in mind create the package json files only with the dependencies required for this package
  state: "open"
  labels:
    - "refactoring"
    - "monorepo"
    - "architecture"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Update claude md file from project"
  body: |
    Suggested .claude/commands/stabilize-cycle.md

    Start a stabilization iteration:

    1. Create failing test for $ARGUMENTS
    2. Push branch
    3. Run full suite, save output log
    4. Commit wip with log
    5. Run Cloud AI analysis
    6. Apply suggestions
    7. Re-run tests
    8. Repeat until stable

    List of Things Belonging in CLAUDE.md:

        Project overview (layout, commands)

        Workflow/branching rules

        Stabilization loop steps (written above)

        Style and tooling conventions

        File placement guidelines

        Slash‑command references

        Where to store logs or generated artifacts
  state: "open"
  labels:
    - "documentation"
    - "claude"
    - "workflow"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "Service should be able to \"implements\" multiple interfaces and Inject<I1,I2,I3>"
  body: |
    check out how spring handles this, maybe easier as documentation artifact/recipe:

    ```typescript
     interface AllInterfaces extends Foo,Bar,Baz"

     @Service()
     class MyService implements AllInterfaces
    ```
  state: "open"
  labels:
    - "enhancement"
    - "dependency-injection"
    - "interfaces"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "[out-of-scope] Immutability"
  body: |
    https://github.com/aleclarson/valtio-kit
  state: "open"
  labels:
    - "enhancement"
    - "immutability"
    - "out-of-scope"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"

- title: "[out-of-scope] ast plugin to search for valtios useSnapshot and optimize re-renders"
  body: |
    currently injection a service and using valtio, will re-render components fully each time one property of the state changes
    - This is definitely out of scope until the core api is stable and proved a decent adoption if any
    - This plugin also could be a standalone and would not necessarily have to be coupled to our code base
    - this compile step would leave us mostly with what svelte does (maybe still more effective)
  state: "open"
  labels:
    - "enhancement"
    - "performance"
    - "ast"
    - "out-of-scope"
  created_at: "2024-01-01T10:00:00Z"
  updated_at: "2024-01-01T10:00:00Z"