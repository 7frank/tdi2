// src/di/context.tsx - Enhanced with functional DI support

import React, { createContext, useContext, ReactNode } from "react";
import { type DIContainer } from '@tdi2/di-core/types';
import { CompileTimeDIContainer } from "./container";

const DIContext = createContext<DIContainer | null>(null);

interface DIProviderProps {
  container?: DIContainer;
  children: ReactNode;
}

export function DIProvider({ container, children }: DIProviderProps) {
  const diContainer = container || new CompileTimeDIContainer();

  return (
    <DIContext.Provider value={diContainer}>{children}</DIContext.Provider>
  );
}

export function useDI(): DIContainer {
  const container = useContext(DIContext);
  if (!container) {
    throw new Error("useDI must be used within a DIProvider");
  }
  return container;
}

/**
 * Hook to resolve a service from the DI container
 */
export function useService<T>(
  token: string | symbol | (new (...args: any[]) => T)
): T {
  const container = useDI();
  return container.resolve<T>(token);
}

/**
 * Hook to optionally resolve a service from the DI container
 * Returns undefined if the service is not registered
 */
export function useOptionalService<T>(
  token: string | symbol | (new (...args: any[]) => T)
): T | undefined {
  const container = useDI();
  try {
    if (container.has(token)) {
      return container.resolve<T>(token);
    }
    return undefined;
  } catch (error) {
    console.warn(`Optional service not found: ${String(token)}`);
    return undefined;
  }
}

/**
 * Hook to resolve multiple services at once
 * Useful for functional components with many dependencies
 */
export function useServices<T extends Record<string, any>>(
  serviceMap: { [K in keyof T]: string | symbol }
): T {
  const container = useDI();
  const services = {} as T;
  
  for (const [key, token] of Object.entries(serviceMap)) {
    services[key as keyof T] = container.resolve(token);
  }
  
  return services;
}

/**
 * Hook for functional DI pattern
 * This would be generated by the transformer for functions with marker interfaces
 */
export function useFunctionalDI<T extends Record<string, any>>(
  dependencies: Array<{
    key: keyof T;
    token: string | symbol;
    optional?: boolean;
  }>
): T {
  const container = useDI();
  const services = {} as T;
  
  for (const dep of dependencies) {
    if (dep.optional) {
      try {
        if (container.has(dep.token)) {
          services[dep.key] = container.resolve(dep.token);
        }
      } catch (error) {
        // Optional dependency not available
        console.warn(`Optional dependency not available: ${String(dep.token)}`);
      }
    } else {
      services[dep.key] = container.resolve(dep.token);
    }
  }
  
  return services;
}