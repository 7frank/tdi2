// src/di/context.tsx - Enhanced with functional DI support
import * as React from "react";
import { createContext, useContext, type ReactNode } from "react";
import { type DIContainer } from "./types";
import { CompileTimeDIContainer } from "./container";
import { proxy, useSnapshot } from "valtio";

const DIContext = createContext<DIContainer | null>(null);

interface DIProviderProps {
  container?: DIContainer;
  children: ReactNode;
}

export function DIProvider({ container, children }: DIProviderProps) {
  const diContainer = container || new CompileTimeDIContainer();

  return (
    <DIContext.Provider value={diContainer}>{children}</DIContext.Provider>
  );
}

export function useDI(): DIContainer {
  const container = useContext(DIContext);
  if (!container) {
    throw new Error("useDI must be used within a DIProvider");
  }
  return container;
}

/**
 * Hook to resolve a service from the DI container with automatic lifecycle management
 */
export function useService(token: string | symbol) {
  const container = useDI();
  const [service] = React.useState(() => {
    const instance = container.resolve(token);
    if (instance === undefined) {
      throw new Error(`Service not found: ${String(token)}`);
    }
    return proxy(instance);
  });

  // Automatic lifecycle management
  React.useEffect(() => {
    const abortController = new AbortController();
    
    // Execute onMount lifecycle if service implements OnMount interface
    if (container.hasLifecycleHooks && typeof container.hasLifecycleHooks === 'function') {
      const lifecycleInfo = container.hasLifecycleHooks(service);
      if (lifecycleInfo.onMount) {
        container.executeOnMountLifecycle(service, { signal: abortController.signal })
          .catch(error => console.error('onMount lifecycle failed:', error));
      }
    }

    // Cleanup function for onUnmount lifecycle
    return () => {
      abortController.abort();
      
      if (container.hasLifecycleHooks && typeof container.hasLifecycleHooks === 'function') {
        const lifecycleInfo = container.hasLifecycleHooks(service);
        if (lifecycleInfo.onUnmount) {
          container.executeOnUnmountLifecycle(service)
            .catch(error => console.error('onUnmount lifecycle failed:', error));
        }
      }
    };
  }, []); // Empty dependency array - lifecycle runs once per service instance

  useSnapshot(service);
  return service;
}

/**
 * Hook to optionally resolve a service from the DI container with automatic lifecycle management
 * Returns undefined if the service is not registered
 */
export function useOptionalService<T>(
  token: string | symbol 
): T | undefined {
  const container = useDI();
  const [service] = React.useState(() => {
    try {
      if (container.has(token)) {
        const instance = container.resolve<T>(token);
        return instance ? proxy(instance as any) : undefined;
      }
      return undefined;
    } catch (error) {
      console.warn(`Optional service not found: ${String(token)}`);
      return undefined;
    }
  });

  // Automatic lifecycle management for optional services
  React.useEffect(() => {
    if (!service) return; // No service, no lifecycle

    const abortController = new AbortController();
    
    // Execute onMount lifecycle if service implements OnMount interface
    if (container.hasLifecycleHooks && typeof container.hasLifecycleHooks === 'function') {
      const lifecycleInfo = container.hasLifecycleHooks(service);
      if (lifecycleInfo.onMount) {
        container.executeOnMountLifecycle(service, { signal: abortController.signal })
          .catch(error => console.error('onMount lifecycle failed:', error));
      }
    }

    // Cleanup function for onUnmount lifecycle
    return () => {
      abortController.abort();
      
      if (container.hasLifecycleHooks && typeof container.hasLifecycleHooks === 'function') {
        const lifecycleInfo = container.hasLifecycleHooks(service);
        if (lifecycleInfo.onUnmount) {
          container.executeOnUnmountLifecycle(service)
            .catch(error => console.error('onUnmount lifecycle failed:', error));
        }
      }
    };
  }, []); // Empty dependency array - lifecycle runs once per service instance

  if (service) {
    useSnapshot(service);
  }
  return service as T | undefined;
}

/**
 * Hook to resolve multiple services at once
 * Useful for functional components with many dependencies
 */
export function useServices<T extends Record<string, any>>(serviceMap: {
  [K in keyof T]: string | symbol;
}): T {
  const container = useDI();
  const services = {} as T;

  for (const [key, token] of Object.entries(serviceMap)) {
    services[key as keyof T] = container.resolve(token);
  }

  return services;
}

/**
 * Hook for functional DI pattern
 * This would be generated by the transformer for functions with marker interfaces
 */
export function useFunctionalDI<T extends Record<string, any>>(
  dependencies: Array<{
    key: keyof T;
    token: string | symbol;
    optional?: boolean;
  }>
): T {
  const container = useDI();
  const services = {} as T;

  for (const dep of dependencies) {
    if (dep.optional) {
      try {
        if (container.has(dep.token)) {
          services[dep.key] = container.resolve(dep.token);
        }
      } catch (error) {
        // Optional dependency not available
        console.warn(`Optional dependency not available: ${String(dep.token)}`);
      }
    } else {
      services[dep.key] = container.resolve(dep.token);
    }
  }

  return services;
}
