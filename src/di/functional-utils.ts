// src/di/functional-utils.ts - Runtime utilities for functional DI

import React from "react";
import { useService, useOptionalService, useFunctionalDI } from "./context";
import type {
  Inject,
  InjectOptional,
  ServiceDependencies,
  ExtractServices,
} from "./markers";

/**
 * Runtime helper to create a DI-enabled functional component
 * This would typically be generated by the transformer, but can be used manually
 */
export function createDIComponent<
  TServices extends ServiceDependencies,
  TProps = {}
>(
  component: (
    props: TProps & { services: ExtractServices<TServices> }
  ) => React.ReactElement,
  serviceDependencies: TServices
): React.ComponentType<TProps> {
  const WrappedComponent = (props: TProps) => {
    // Extract dependency configuration from marker types
    const dependencyConfig = extractDependencyConfig(serviceDependencies);

    // Use the functional DI hook to resolve services
    const services = useFunctionalDI(dependencyConfig);

    // Call original component with injected services
    return component({ ...props, services } as TProps & {
      services: ExtractServices<TServices>;
    });
  };

  WrappedComponent.displayName = `DIComponent(${component.name})`;
  return WrappedComponent;
}

/**
 * Helper to create service dependencies configuration
 */
export function createServiceConfig<T extends ServiceDependencies>(
  config: T
): T {
  return config;
}

/**
 * Extract dependency configuration from marker interfaces
 * This function analyzes the service dependencies and creates the runtime config
 */
function extractDependencyConfig(
  serviceDependencies: ServiceDependencies
): Array<{
  key: string;
  token: string | symbol;
  optional?: boolean;
}> {
  // In a real implementation, this would use reflection or be generated at compile time
  // For now, we'll use a simple mapping approach

  const config: Array<{
    key: string;
    token: string | symbol;
    optional?: boolean;
  }> = [];

  // This is a simplified version - the real transformer would generate this
  for (const [key, markerType] of Object.entries(serviceDependencies)) {
    // Extract token from marker type metadata
    // In practice, this would be pre-computed by the transformer
    const token = inferTokenFromKey(key);
    const optional = isOptionalMarker(markerType);

    config.push({
      key,
      token,
      optional,
    });
  }

  return config;
}

/**
 * Simple token inference based on key name
 * The transformer would have more sophisticated logic
 */
function inferTokenFromKey(key: string): string {
  const tokenMap: Record<string, string> = {
    api: "EXAMPLE_API_TOKEN",
    logger: "LOGGER_TOKEN",
    cache: "CACHE_TOKEN",
    auth: "AUTH_TOKEN",
  };

  return tokenMap[key] || key.toUpperCase() + "_TOKEN";
}

/**
 * Check if a marker type is optional
 * In practice, this would be determined at compile time
 */
function isOptionalMarker(markerType: any): boolean {
  // This is a placeholder - the real implementation would use type metadata
  return false; // The transformer would set this correctly
}
