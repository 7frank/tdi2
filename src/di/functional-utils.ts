// src/di/functional-utils.ts - Runtime utilities for functional DI

import React from 'react';
import { useService, useOptionalService, useFunctionalDI } from './context';
import type { Inject, InjectOptional, ServiceDependencies, ExtractServices } from './markers';

/**
 * Runtime helper to create a DI-enabled functional component
 * This would typically be generated by the transformer, but can be used manually
 */
export function createDIComponent<TServices extends ServiceDependencies, TProps = {}>(
  component: (props: TProps & { services: ExtractServices<TServices> }) => React.ReactElement,
  serviceDependencies: TServices
): React.ComponentType<TProps> {
  
  const WrappedComponent = (props: TProps) => {
    // Extract dependency configuration from marker types
    const dependencyConfig = extractDependencyConfig(serviceDependencies);
    
    // Use the functional DI hook to resolve services
    const services = useFunctionalDI(dependencyConfig);
    
    // Call original component with injected services
    return component({ ...props, services } as TProps & { services: ExtractServices<TServices> });
  };

  WrappedComponent.displayName = `DIComponent(${component.name})`;
  return WrappedComponent;
}

/**
 * Manual service injection hook for functional components
 * Use this when you want explicit control over service resolution
 */
export function useInjectServices<T extends Record<string, string | symbol>>(
  serviceTokens: T
): { [K in keyof T]: any } {
  const services = {} as { [K in keyof T]: any };
  
  for (const [key, token] of Object.entries(serviceTokens)) {
    services[key as keyof T] = useService(token);
  }
  
  return services;
}

/**
 * Helper to create service dependencies configuration
 */
export function createServiceConfig<T extends ServiceDependencies>(config: T): T {
  return config;
}

/**
 * Extract dependency configuration from marker interfaces
 * This function analyzes the service dependencies and creates the runtime config
 */
function extractDependencyConfig(serviceDependencies: ServiceDependencies): Array<{
  key: string;
  token: string | symbol;
  optional?: boolean;
}> {
  // In a real implementation, this would use reflection or be generated at compile time
  // For now, we'll use a simple mapping approach
  
  const config: Array<{
    key: string;
    token: string | symbol;
    optional?: boolean;
  }> = [];

  // This is a simplified version - the real transformer would generate this
  for (const [key, markerType] of Object.entries(serviceDependencies)) {
    // Extract token from marker type metadata
    // In practice, this would be pre-computed by the transformer
    const token = inferTokenFromKey(key);
    const optional = isOptionalMarker(markerType);
    
    config.push({
      key,
      token,
      optional
    });
  }

  return config;
}

/**
 * Simple token inference based on key name
 * The transformer would have more sophisticated logic
 */
function inferTokenFromKey(key: string): string {
  const tokenMap: Record<string, string> = {
    'api': 'EXAMPLE_API_TOKEN',
    'logger': 'LOGGER_TOKEN',
    'cache': 'CACHE_TOKEN',
    'auth': 'AUTH_TOKEN'
  };
  
  return tokenMap[key] || key.toUpperCase() + '_TOKEN';
}

/**
 * Check if a marker type is optional
 * In practice, this would be determined at compile time
 */
function isOptionalMarker(markerType: any): boolean {
  // This is a placeholder - the real implementation would use type metadata
  return false; // The transformer would set this correctly
}

/**
 * Decorator factory for functional components (experimental)
 * Usage: @functionalDI({ api: 'EXAMPLE_API_TOKEN' })
 */
export function functionalDI<T extends Record<string, string | symbol>>(
  serviceTokens: T
) {
  return function <TProps extends {}>(
    target: (props: TProps & { services: { [K in keyof T]: any } }) => React.ReactElement
  ) {
    const WrappedComponent = (props: TProps) => {
      const services = useInjectServices(serviceTokens);
      return target({ ...props, services } as TProps & { services: { [K in keyof T]: any } });
    };
    
    WrappedComponent.displayName = `@functionalDI(${target.name})`;
    return WrappedComponent;
  };
}

/**
 * Helper to create a service injection hook for a specific component
 */
export function createServiceHook<T extends Record<string, string | symbol>>(
  serviceTokens: T
) {
  return (): { [K in keyof T]: any } => {
    return useInjectServices(serviceTokens);
  };
}

// Example usage:
/*
// Manual approach
const useMyServices = createServiceHook({
  api: 'EXAMPLE_API_TOKEN',
  logger: 'LOGGER_TOKEN'
});

function MyComponent(props: { title: string }) {
  const services = useMyServices();
  // Use services.api and services.logger
}

// HOC approach
const MyComponentWithDI = createDIComponent(
  ({ title, services }) => {
    // Use services here
    return <div>{title}</div>;
  },
  createServiceConfig({
    api: {} as Inject<ExampleApiInterface>,
    logger: {} as InjectOptional<LoggerService>
  })
);
*/