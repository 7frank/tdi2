// tools/config-manager.ts - Manages configuration hashing and bridge files

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';
import { createRequire } from 'module';

interface DIConfigOptions {
  srcDir: string;
  outputDir: string;
  enableFunctionalDI: boolean;
  verbose: boolean;
  nodeEnv?: string;
  customSuffix?: string;
}

export class ConfigManager {
  private configHash: string;
  private configDir: string;
  private bridgeDir: string;
  private options: DIConfigOptions;
  private packageName: string;

  constructor(options: DIConfigOptions) {
    this.options = {
      nodeEnv: process.env.NODE_ENV || 'development',
      ...options
    };
    
    this.packageName = this.getPackageName();
    this.configHash = this.generateConfigHash();
    this.configDir = path.resolve(`node_modules/.tdi2/configs/${this.configHash}`);
    this.bridgeDir = path.resolve(options.srcDir, '.tdi2');
    
    this.ensureDirectories();
  }

  private getPackageName(): string {
    try {
      const require = createRequire(import.meta.url);
      const packageJson = require(path.resolve('package.json'));
      return packageJson.name || 'unknown';
    } catch {
      return 'unknown';
    }
  }

  private generateConfigHash(): string {
    const hashInput = {
      srcDir: path.resolve(this.options.srcDir),
      enableFunctionalDI: this.options.enableFunctionalDI,
      nodeEnv: this.options.nodeEnv,
      packageName: this.packageName,
      customSuffix: this.options.customSuffix || ''
    };

    const hashString = JSON.stringify(hashInput, Object.keys(hashInput).sort());
    const hash = crypto.createHash('sha256').update(hashString).digest('hex').substring(0, 8);
    
    return `${this.packageName}-${this.options.nodeEnv}-${hash}`;
  }

  private ensureDirectories(): void {
    // Ensure config directory exists
    if (!fs.existsSync(this.configDir)) {
      fs.mkdirSync(this.configDir, { recursive: true });
    }

    // Ensure bridge directory exists
    if (!fs.existsSync(this.bridgeDir)) {
      fs.mkdirSync(this.bridgeDir, { recursive: true });
    }

    // Create transformed subdirectory
    const transformedDir = path.join(this.configDir, 'transformed');
    if (!fs.existsSync(transformedDir)) {
      fs.mkdirSync(transformedDir, { recursive: true });
    }

    // Write config metadata for debugging
    this.writeConfigMetadata();
  }

  private writeConfigMetadata(): void {
    const metadata = {
      configHash: this.configHash,
      generatedAt: new Date().toISOString(),
      options: this.options,
      packageName: this.packageName,
      paths: {
        configDir: this.configDir,
        bridgeDir: this.bridgeDir
      }
    };

    fs.writeFileSync(
      path.join(this.configDir, '.config-meta.json'),
      JSON.stringify(metadata, null, 2)
    );
  }

  generateBridgeFiles(): void {
    if (this.options.verbose) {
      console.log(`üåâ Generating bridge files in ${this.bridgeDir}`);
    }

    // Generate DI config bridge
    this.generateDIConfigBridge();
    
    // Generate registry bridge
    this.generateRegistryBridge();

    // Generate .gitignore for bridge directory
    this.generateBridgeGitignore();

    if (this.options.verbose) {
      console.log(`‚úÖ Bridge files generated for config: ${this.configHash}`);
    }
  }

  private generateDIConfigBridge(): void {
    const relativePath = path.relative(
      this.bridgeDir,
      path.join(this.configDir, 'di-config.ts')
    ).replace(/\\/g, '/');

    const bridgeContent = `// Auto-generated bridge file - do not edit
// Config: ${this.configHash}
// Generated: ${new Date().toISOString()}

export * from '${relativePath}';
`;

    fs.writeFileSync(
      path.join(this.bridgeDir, 'di-config.ts'),
      bridgeContent
    );
  }

  private generateRegistryBridge(): void {
    const relativePath = path.relative(
      this.bridgeDir,
      path.join(this.configDir, 'AutoGeneratedRegistry.ts')
    ).replace(/\\/g, '/');

    const bridgeContent = `// Auto-generated bridge file - do not edit
// Config: ${this.configHash}
// Generated: ${new Date().toISOString()}

export * from '${relativePath}';
`;

    fs.writeFileSync(
      path.join(this.bridgeDir, 'registry.ts'),
      bridgeContent
    );
  }

  private generateBridgeGitignore(): void {
    const gitignoreContent = `# Auto-generated TDI2 bridge files
*
!.gitignore
!README.md
`;

    fs.writeFileSync(
      path.join(this.bridgeDir, '.gitignore'),
      gitignoreContent
    );

    // Also create a README for clarity
    const readmeContent = `# TDI2 Bridge Files

This directory contains auto-generated bridge files that connect your source code to the actual DI configuration files.

**Do not edit these files manually** - they are regenerated automatically.

## Current Configuration
- Config Hash: ${this.configHash}
- Config Directory: ${this.configDir}
- Generated: ${new Date().toISOString()}

## Files
- \`di-config.ts\` - Exports DI configuration
- \`registry.ts\` - Exports service registry
`;

    fs.writeFileSync(
      path.join(this.bridgeDir, 'README.md'),
      readmeContent
    );
  }

  // Getters for other classes to use
  getConfigDir(): string {
    return this.configDir;
  }

  getBridgeDir(): string {
    return this.bridgeDir;
  }

  getConfigHash(): string {
    return this.configHash;
  }

  getTransformedDir(): string {
    return path.join(this.configDir, 'transformed');
  }

  // Clean up old configurations
  static cleanOldConfigs(keepCount: number = 3): void {
    const tdi2Dir = path.resolve('node_modules/.tdi2/configs');
    
    if (!fs.existsSync(tdi2Dir)) {
      return;
    }

    try {
      const configs = fs.readdirSync(tdi2Dir)
        .map(name => ({
          name,
          path: path.join(tdi2Dir, name),
          stats: fs.statSync(path.join(tdi2Dir, name))
        }))
        .filter(item => item.stats.isDirectory())
        .sort((a, b) => b.stats.mtime.getTime() - a.stats.mtime.getTime());

      // Keep the most recent configs, remove the rest
      const toRemove = configs.slice(keepCount);
      
      for (const config of toRemove) {
        fs.rmSync(config.path, { recursive: true, force: true });
        console.log(`üóëÔ∏è  Cleaned up old config: ${config.name}`);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  Failed to clean old configs:', error);
    }
  }
}